use crate::ast::*;
use crate::templateGen::template_generator::{CodeGenerator, GeneratorOptions, helpers};
use anyhow::Result;

/// Go code generator
pub struct GoGenerator {
    options: GeneratorOptions,
}

impl GoGenerator {
    pub fn new(options: GeneratorOptions) -> Self {
        Self { options }
    }
}

impl CodeGenerator for GoGenerator {
    fn generate(&self, proto_file: &ProtoFile) -> Result<String> {
        let mut code = String::new();
        
        // Add header comment
        code.push_str(&format!(
            "// Generated by protoc-gen-dmxp for package: {}\n",
            proto_file.package
        ));
        code.push_str("// DO NOT EDIT - This file is auto-generated\n\n");
        
        // Add package declaration
        let package_name = self.options.package_override
            .as_ref()
            .unwrap_or(&proto_file.package)
            .replace("-", "_");
        code.push_str(&format!("package {}\n\n", package_name));
        
        // Add imports
        code.push_str("import (\n");
        code.push_str("\t\"context\"\n");
        code.push_str("\t\"encoding/json\"\n");
        if self.options.include_dmxp {
            code.push_str("\t\"github.com/dmxp/dmxp-go\"\n");
        }
        code.push_str(")\n\n");
        
        // Generate enums first
        for enum_def in &proto_file.enums {
            code.push_str(&self.generate_enum(enum_def)?);
            code.push_str("\n");
        }
        
        // Generate messages
        for message in &proto_file.messages {
            code.push_str(&self.generate_message(message)?);
            code.push_str("\n");
        }
        
        // Generate services
        for service in &proto_file.services {
            code.push_str(&self.generate_service(service)?);
            code.push_str("\n");
        }
        
        // Generate DMXP channels
        if self.options.include_dmxp {
            code.push_str(&self.generate_dmxp_channels(proto_file)?);
        }
        
        Ok(code)
    }
}

impl GoGenerator {
    /// Generate Go enum
    fn generate_enum(&self, enum_def: &Enum) -> Result<String> {
        let mut code = String::new();
        
        code.push_str(&format!("type {} int32\n\n", enum_def.name));
        code.push_str("const (\n");
        
        for value in &enum_def.values {
            code.push_str(&format!(
                "\t{}_{} {} = {}\n",
                enum_def.name.to_uppercase(),
                value.name,
                enum_def.name,
                value.number
            ));
        }
        
        code.push_str(")\n");
        
        // Generate methods
        code.push_str(&format!(
            r#"
func (e {}) String() string {{
    switch e {{
"#,
            enum_def.name
        ));
        
        for value in &enum_def.values {
            code.push_str(&format!(
                "\tcase {}_{}:\n\t\treturn \"{}\"\n",
                enum_def.name.to_uppercase(),
                value.name,
                value.name
            ));
        }
        
        code.push_str("\tdefault:\n\t\treturn \"UNKNOWN\"\n");
        code.push_str("\t}\n");
        code.push_str("}\n");
        
        // Generate FromNumber method
        code.push_str(&format!(
            r#"
func {}FromNumber(num int32) ({} {}) {{
    switch num {{
"#,
            enum_def.name, enum_def.name, enum_def.name
        ));
        
        for value in &enum_def.values {
            code.push_str(&format!(
                "\tcase {}:\n\t\treturn {}_{}\n",
                value.number,
                enum_def.name.to_uppercase(),
                value.name
            ));
        }
        
        code.push_str("\tdefault:\n\t\treturn 0\n");
        code.push_str("\t}\n");
        code.push_str("}\n");
        
        Ok(code)
    }

    /// Generate Go message struct
    fn generate_message(&self, message: &Message) -> Result<String> {
        let mut code = String::new();
        
        // Generate the main struct
        code.push_str(&format!("type {} struct {{\n", message.name));
        
        for field in &message.fields {
            let field_type = self.convert_field_type(field);
            let field_name = helpers::convert_field_name(&field.name, &crate::templateGen::template_generator::Language::Go);
            let json_tag = format!("json:\"{}\"", field.name);
            
            code.push_str(&format!(
                "\t{} {} `{}`\n",
                field_name, field_type, json_tag
            ));
        }
        
        code.push_str("}\n");
        
        // Generate constructor
        code.push_str(&format!(
            r#"
func New{}() *{} {{
    return &{}{{
"#,
            message.name, message.name, message.name
        ));
        
        for field in &message.fields {
            let field_name = helpers::convert_field_name(&field.name, &crate::templateGen::template_generator::Language::Go);
            let default_value = self.get_default_value(field);
            code.push_str(&format!("\t\t{}: {},\n", field_name, default_value));
        }
        
        code.push_str("\t}\n");
        code.push_str("}\n");
        
        // Generate DMXP methods if applicable
        if self.options.include_dmxp {
            code.push_str(&helpers::generate_dmxp_channel_code(message, &crate::templateGen::template_generator::Language::Go));
        }
        
        Ok(code)
    }

    /// Generate Go service
    fn generate_service(&self, service: &Service) -> Result<String> {
        let mut code = String::new();
        
        let service_name = &service.name;
        let service_struct_name = format!("{}Service", service_name);
        
        // Generate service struct
        code.push_str(&format!("type {} struct {{\n", service_struct_name));
        if self.options.include_dmxp {
            code.push_str("\tcontext *dmxp.Context\n");
        }
        code.push_str("}\n");
        
        // Generate constructor
        code.push_str(&format!(
            r#"
func New{}Service(context *dmxp.Context) *{} {{
    return &{}{{
        context: context,
    }}
}}
"#,
            service_name, service_struct_name, service_struct_name
        ));
        
        // Generate methods
        for method in &service.methods {
            if self.options.use_async {
                code.push_str(&format!(
                    r#"
func (s *{}) {}(ctx context.Context, request *{}) (*{}, error) {{
    // TODO: Implement {} method
    return nil, fmt.Errorf("method {} not implemented")
}}
"#,
                    service_struct_name, method.name, method.input_type, method.output_type, method.name, method.name
                ));
            } else {
                code.push_str(&format!(
                    r#"
func (s *{}) {}(request *{}) (*{}, error) {{
    // TODO: Implement {} method
    return nil, fmt.Errorf("method {} not implemented")
}}
"#,
                    service_struct_name, method.name, method.input_type, method.output_type, method.name, method.name
                ));
            }
        }
        
        Ok(code)
    }

    /// Generate DMXP channels
    fn generate_dmxp_channels(&self, proto_file: &ProtoFile) -> Result<String> {
        let mut code = String::new();
        
        code.push_str("// DMXP Channel implementations\n");
        
        for message in &proto_file.messages {
            if let Some(dmxp_opts) = &message.dmxp_options {
                if let Some(channel) = &dmxp_opts.channel {
                    code.push_str(&format!(
                        r#"
// Channel: {}
func (m *{}) PublishTo{}(publisher *dmxp.Publisher) error {{
    return publisher.Publish("{}", m)
}}

func SubscribeTo{}(callback func(*{}) error) error {{
    return dmxp.Subscribe("{}", callback)
}}
"#,
                        channel,
                        message.name,
                        self.to_pascal_case(&channel.replace("-", "_")),
                        channel,
                        self.to_pascal_case(&channel.replace("-", "_")),
                        message.name,
                        channel
                    ));
                }
            }
        }
        
        Ok(code)
    }

    /// Convert field type to Go type
    fn convert_field_type(&self, field: &Field) -> String {
        let base_type = helpers::convert_field_type(&field.field_type, &crate::templateGen::template_generator::Language::Go);
        
        match field.label {
            FieldLabel::Optional => format!("*{}", base_type),
            FieldLabel::Repeated => format!("[]{}", base_type),
            FieldLabel::Required => base_type,
        }
    }

    /// Get default value for a field
    fn get_default_value(&self, field: &Field) -> String {
        match field.label {
            FieldLabel::Optional => "nil".to_string(),
            FieldLabel::Repeated => "nil".to_string(),
            FieldLabel::Required => match field.field_type {
                FieldType::String => "\"\"".to_string(),
                FieldType::Bytes => "nil".to_string(),
                FieldType::Int32 | FieldType::Int64 | FieldType::Uint32 | FieldType::Uint64 => "0".to_string(),
                FieldType::Float | FieldType::Double => "0.0".to_string(),
                FieldType::Bool => "false".to_string(),
                _ => "{}".to_string(),
            },
        }
    }

    /// Convert to PascalCase
    fn to_pascal_case(&self, s: &str) -> String {
        s.split('_')
            .map(|word| {
                let mut chars = word.chars();
                match chars.next() {
                    None => String::new(),
                    Some(first) => first.to_uppercase().chain(chars).collect(),
                }
            })
            .collect()
    }
}
