use crate::ast::*;
use crate::templateGen::template_generator::{CodeGenerator, GeneratorOptions, helpers};
use anyhow::Result;

/// Rust code generator
pub struct RustGenerator {
    options: GeneratorOptions,
}

impl RustGenerator {
    pub fn new(options: GeneratorOptions) -> Self {
        Self { options }
    }
}

impl CodeGenerator for RustGenerator {
    fn generate(&self, proto_file: &ProtoFile) -> Result<String> {
        let mut code = String::new();
        
        // Add header comment
        code.push_str(&format!(
            "// Generated by protoc-gen-dmxp for package: {}\n",
            proto_file.package
        ));
        code.push_str("// DO NOT EDIT - This file is auto-generated\n\n");
        
        // Add imports
        code.push_str("use serde::{Deserialize, Serialize};\n");
        if self.options.include_dmxp {
            code.push_str("use dmxp::{Publisher, Subscriber, Context, Error as DmxpError};\n");
        }
        code.push_str("use std::collections::HashMap;\n");
        if self.options.use_async {
            code.push_str("use tokio::sync::RwLock;\n");
        }
        code.push_str("\n");
        
        // Generate enums first
        for enum_def in &proto_file.enums {
            code.push_str(&self.generate_enum(enum_def)?);
            code.push_str("\n");
        }
        
        // Generate messages
        for message in &proto_file.messages {
            code.push_str(&self.generate_message(message)?);
            code.push_str("\n");
        }
        
        // Generate services
        for service in &proto_file.services {
            code.push_str(&self.generate_service(service)?);
            code.push_str("\n");
        }
        
        // Generate DMXP channels
        if self.options.include_dmxp {
            code.push_str(&self.generate_dmxp_channels(proto_file)?);
        }
        
        Ok(code)
    }
}

impl RustGenerator {
    /// Generate Rust enum
    fn generate_enum(&self, enum_def: &Enum) -> Result<String> {
        let mut code = String::new();
        
        code.push_str(&format!("#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]\n"));
        code.push_str(&format!("pub enum {} {{\n", enum_def.name));
        
        for value in &enum_def.values {
            code.push_str(&format!("    {},\n", value.name));
        }
        
        code.push_str("}\n");
        
        // Generate implementation methods
        code.push_str(&format!(
            r#"
impl {} {{
    pub fn from_number(num: i32) -> Option<Self> {{
        match num {{
"#,
            enum_def.name
        ));
        
        for value in &enum_def.values {
            code.push_str(&format!("            {} => Some({}::{}),\n", value.number, enum_def.name, value.name));
        }
        
        code.push_str("            _ => None,\n");
        code.push_str("        }\n");
        code.push_str("    }\n");
        
        code.push_str(&format!(
            r#"
    pub fn to_number(&self) -> i32 {{
        match self {{
"#,
        ));
        
        for value in &enum_def.values {
            code.push_str(&format!("            {}::{} => {},\n", enum_def.name, value.name, value.number));
        }
        
        code.push_str("        }\n");
        code.push_str("    }\n");
        code.push_str("}\n");
        
        Ok(code)
    }

    /// Generate Rust message struct
    fn generate_message(&self, message: &Message) -> Result<String> {
        let mut code = String::new();
        
        // Generate the main struct
        code.push_str(&format!("#[derive(Debug, Clone, Serialize, Deserialize)]\n"));
        code.push_str(&format!("pub struct {} {{\n", message.name));
        
        for field in &message.fields {
            let field_type = self.convert_field_type(field);
            let field_name = helpers::convert_field_name(&field.name, &crate::templateGen::template_generator::Language::Rust);
            
            code.push_str(&format!("    pub {}: {},\n", field_name, field_type));
        }
        
        code.push_str("}\n");
        
        // Generate implementation
        code.push_str(&format!(
            r#"
impl {} {{
    pub fn new() -> Self {{
        Self {{
"#,
            message.name
        ));
        
        for field in &message.fields {
            let field_name = helpers::convert_field_name(&field.name, &crate::templateGen::template_generator::Language::Rust);
            let default_value = self.get_default_value(field);
            code.push_str(&format!("            {}: {},\n", field_name, default_value));
        }
        
        code.push_str("        }\n");
        code.push_str("    }\n");
        
        // Generate DMXP methods if applicable
        if self.options.include_dmxp {
            code.push_str(&helpers::generate_dmxp_channel_code(message, &crate::templateGen::template_generator::Language::Rust));
        }
        
        code.push_str("}\n");
        
        // Generate Default implementation
        code.push_str(&format!(
            r#"
impl Default for {} {{
    fn default() -> Self {{
        Self::new()
    }}
}}"#,
            message.name
        ));
        
        Ok(code)
    }

    /// Generate Rust service
    fn generate_service(&self, service: &Service) -> Result<String> {
        let mut code = String::new();
        
        let service_name = &service.name;
        let service_struct_name = format!("{}Service", service_name);
        
        // Generate service struct
        code.push_str(&format!("#[derive(Debug, Clone)]\n"));
        code.push_str(&format!("pub struct {} {{\n", service_struct_name));
        if self.options.include_dmxp {
            code.push_str("    context: Context,\n");
        }
        code.push_str("}\n");
        
        // Generate implementation
        code.push_str(&format!(
            r#"
impl {} {{
    pub fn new(context: Context) -> Self {{
        Self {{
            context,
        }}
    }}
"#,
            service_struct_name
        ));
        
        // Generate methods
        for method in &service.methods {
            if self.options.use_async {
                code.push_str(&format!(
                    r#"
    pub async fn {}(&self, request: {}) -> Result<{}, DmxpError> {{
        // TODO: Implement {} method
        todo!("Implement {} method")
    }}
"#,
                    method.name, method.input_type, method.output_type, method.name, method.name
                ));
            } else {
                code.push_str(&format!(
                    r#"
    pub fn {}(&self, request: {}) -> Result<{}, DmxpError> {{
        // TODO: Implement {} method
        todo!("Implement {} method")
    }}
"#,
                    method.name, method.input_type, method.output_type, method.name, method.name
                ));
            }
        }
        
        code.push_str("}\n");
        
        Ok(code)
    }

    /// Generate DMXP channels
    fn generate_dmxp_channels(&self, proto_file: &ProtoFile) -> Result<String> {
        let mut code = String::new();
        
        code.push_str("// DMXP Channel implementations\n");
        
        for message in &proto_file.messages {
            if let Some(dmxp_opts) = &message.dmxp_options {
                if let Some(channel) = &dmxp_opts.channel {
                    code.push_str(&format!(
                        r#"
// Channel: {}
impl {} {{
    pub fn publish_to_{}(&self, publisher: &Publisher) -> Result<(), DmxpError> {{
        publisher.publish("{}", self)
    }}
    
    pub fn subscribe_to_{}(callback: impl Fn({}) -> Result<(), DmxpError> + Send + Sync + 'static) -> Result<(), DmxpError> {{
        dmxp::subscribe("{}", callback)
    }}
}}
"#,
                        channel,
                        message.name,
                        channel.replace("-", "_"),
                        channel,
                        channel.replace("-", "_"),
                        message.name,
                        channel
                    ));
                }
            }
        }
        
        Ok(code)
    }

    /// Convert field type to Rust type
    fn convert_field_type(&self, field: &Field) -> String {
        let base_type = helpers::convert_field_type(&field.field_type, &crate::templateGen::template_generator::Language::Rust);
        
        match field.label {
            FieldLabel::Optional => format!("Option<{}>", base_type),
            FieldLabel::Repeated => format!("Vec<{}>", base_type),
            FieldLabel::Required => base_type,
        }
    }

    /// Get default value for a field
    fn get_default_value(&self, field: &Field) -> String {
        match field.label {
            FieldLabel::Optional => "None".to_string(),
            FieldLabel::Repeated => "Vec::new()".to_string(),
            FieldLabel::Required => match field.field_type {
                FieldType::String => "String::new()".to_string(),
                FieldType::Bytes => "Vec::new()".to_string(),
                FieldType::Int32 | FieldType::Int64 | FieldType::Uint32 | FieldType::Uint64 => "0".to_string(),
                FieldType::Float | FieldType::Double => "0.0".to_string(),
                FieldType::Bool => "false".to_string(),
                _ => "Default::default()".to_string(),
            },
        }
    }
}
